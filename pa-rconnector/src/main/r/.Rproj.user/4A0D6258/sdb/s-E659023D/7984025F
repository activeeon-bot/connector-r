{
    "contents" : "\n# Toplevel function used to analyse the dependencies, it will start the recursion and return :\n# - the list of dependant variable names\n# - an environment containing all variables definition\n# - the list of R packages that are used by the hierarchy\n.PASolve_computeDependencies <- function(funcOrFunName, envir = environment(), variableNames = NULL, newenvir = new.env(), .do.verbose=PADebug()) {\n\n  recurseResult <- .recurseSaveFunctionDependencies(funcOrFunName, envir = envir, newenvir = newenvir, .visitedNames = variableNames, .libraryDependencies={},.do.verbose=.do.verbose, level = 1)\n  if (.do.verbose) {\n    cat(\"The environment remotely sent will contain the following variables : \\n\")\n    print(ls(recurseResult[[\"newenvir\"]], all.names = TRUE))\n    cat(\"The following librairies will be loaded : \\n\")\n    print(recurseResult[[\"libs\"]])\n  }\n  return(list(variableNames = c(variableNames,recurseResult[[\"deps\"]]), newenvir = recurseResult[[\"newenvir\"]], libraryDependencies=recurseResult[[\"libs\"]]))\n}\n\n# internal recursive function to analyse dependencies. \n# It will :\n#  - take the function parameter as either a character name or a lambda\n#  - find all names used in a given function, inside a given environment (workspace)\n#  - use an accumulator to store the functions already inspected (.visitedNames)\n#  - use an accumulator to store all R packages used (.libraryDependencies)\n#  - produce a new environment which will store all the necessary functions and variable definitions\n#  - return the name of the function if it must be stored in dependencies\n.recurseSaveFunctionDependencies <- function(funcOrFuncName, envir=NULL, newenvir=new.env(), .visitedNames={}, .libraryDependencies = {}, .do.verbose=PADebug(), level = 1) {\n  if (typeof(funcOrFuncName) == \"character\") {\n    # function defined by it's name\n    \n    if (is.element(funcOrFuncName, .visitedNames)) {\n      # if in buffer, then already inspected, return the current accumulators\n      return(list(deps = NULL, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n    }\n    \n    .visitedNames <- union( .visitedNames, funcOrFuncName)\n    \n    .print.debug.message(.do.verbose, str_c(\"processing function: '\", funcOrFuncName,\"'\"), level)\n    \n    # if it's a reserved function, end recursion\n    if (is.element(funcOrFuncName, c(\"install.packages\",\"library\",\"require\", \"set_progress\"))) {\n      return(list(deps = NULL, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n    }\n    \n    # find the function definition \n    answerToFind <- .findAndStoreName(funcOrFuncName, envir = envir, .listpackages = .libraryDependencies, newenvir=newenvir, .do.verbose = .do.verbose, level = level)\n\n    if (is.null(answerToFind)) {\n      # function not found, end recursion\n      return(list(deps = NULL, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n    }\n    .libraryDependencies <- answerToFind[[\"listpackages\"]]\n    \n    if (!answerToFind[[\"continue\"]]) {\n      # function inside a package, end recursion\n      return(list(deps = NULL, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n    }\n    # ok, function is a dependency, return it, and store it\n    computedDependencies <- {funcOrFuncName};\n    functionDefinition <- answerToFind[[\"object\"]]\n    \n  } else {\n    .print.debug.message(.do.verbose, \"processing closure variable\", level)\n\n    functionDefinition <- funcOrFuncName;\n    computedDependencies <- {};\n  }\n  \n  # if no environment is provided, use R to grab the function environment\n  if (is.null(envir)) {\n    envir <- environment(functionDefinition)\n  }\n  # find all globals (i.e. variables, functions) defined in this environment\n  globs <- findGlobals(functionDefinition)\n\n  .print.debug.message(.do.verbose, str_c(\" --> found globals : \", toString(globs)), level)\n  \n  for (varName in globs) {\n    # skip all globals related to proactive or library loading\n    if (!is.element(varName, c(\"install.packages\",\"library\",\"require\", \"set_progress\", \"inputspace\",\"outputspace\",\"globalspace\",\"userspace\"))) {\n      # analyse this global\n      answerToFind <- .findAndStoreName(varName, envir = envir, .listpackages = .libraryDependencies, newenvir=newenvir, .do.verbose = .do.verbose, level = level)\n      \n      if (!is.null(answerToFind)) {\n        newenvir <- answerToFind[[\"newenvir\"]]\n        .libraryDependencies <- answerToFind[[\"listpackages\"]]\n        if (!answerToFind[[\"continue\"]]) {\n          next\n        }        \n        \n        varDefinition <- answerToFind[[\"object\"]] \n        envirVar <- environment(varDefinition)\n        typeofVar <- typeof(varDefinition);\n        if (typeofVar == \"closure\") {\n          # if the variable is a \"closure\" (function), then recurse\n          recurseResult <- .recurseSaveFunctionDependencies(varName, envir = envirVar, newenvir = newenvir, .visitedNames = .visitedNames , .libraryDependencies = .libraryDependencies, .do.verbose = .do.verbose, level = level + 1)\n          computedDependencies <- union(computedDependencies, recurseResult[[\"deps\"]]);\n          .visitedNames <- union(.visitedNames, recurseResult[[\"visited\"]]);\n          .libraryDependencies <- union(.libraryDependencies, recurseResult[[\"libs\"]])\n          newenvir <- recurseResult[[\"newenvir\"]]\n          \n        } else if (typeofVar == \"list\") {\n          # if the variable is a list, then recurse\n          computedDependencies <- union(computedDependencies, varName); # adding the list variable name to the output\n          recurseResult <- .recurseSaveListDependencies(varName, envir = envirVar, newenvir = newenvir, .visitedNames = .visitedNames, .libraryDependencies = .libraryDependencies , .do.verbose = .do.verbose, level = level + 1)\n          computedDependencies <- union(computedDependencies, recurseResult[[\"deps\"]]); # adding the dependencies of the list\n          .visitedNames <- union(.visitedNames, recurseResult[[\"visited\"]]);  # merging the already parsed functions\n          .libraryDependencies <- union(.libraryDependencies, recurseResult[[\"libs\"]])\n          newenvir <- recurseResult[[\"newenvir\"]]\n          \n        } else if (is.element(typeofVar,c(\"symbol\",\"logical\",\"integer\", \"double\", \"complex\", \"character\",\"raw\"))) {\n          # if the variable is a terminal type, return it\n          computedDependencies <- union(computedDependencies, varName)\n        }\n      }\n    }\n  }\n  return(list(deps = computedDependencies, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n};\n\n.print.debug.message <- function (.do.verbose, message, level) {\n  if (.do.verbose) {\n    line <- str_dup(\"// \", level)\n    cat(str_c(line,message,\"\\n\"))\n  }\n}\n\n# search the given name anywhere, the name can be a function name or a variable name\n# it returns the object found, recursion continuation decision and a new list of package dependences\n# it also stores the name in the new environment if applicable (it is the better place to do this decision)\n.findAndStoreName <- function(name, envir = NULL, .listpackages = NULL, newenvir = new.env(), .do.verbose = FALSE, level = 1) {\n\n  .print.debug.message(.do.verbose, str_c(\"finding name : \", name), level)\n\n  answerList <- NULL\n  # this code has been commented out as it was too unstable, now we rely on R function getAnywhere systematically\n  \n  # first look for the object in the environment passed in parameter\n  #   answerList <- tryCatch( {\n  #     object <- get(name, envir)\n  #     if (.do.verbose) {\n  #       print(str_c(\" // variable '\", name,\"' added to environment\"))\n  #     }\n  #     assign(name, object, envir=newenvir);\n  #     return(list(object = object, continue = TRUE, listpackages = .listpackages))\n  #   }, error = function(e) {return(NULL)} );\n  \n  # look anywhere\n  if (is.null(answerList)) {\n    answerList <- tryCatch( {\n      anywhereList <- getAnywhere(name)\n      \n      if (!is.null(anywhereList) && (length(anywhereList[[\"objs\"]]) > 0)) {\n        .print.debug.message(.do.verbose, str_c(\"--> found in :\",str_c(anywhereList[[\"where\"]],collapse=' ')), level)\n        aL <- .appendLibraryDependencies(anywhereList[[\"where\"]][[1]], .listpackages = .listpackages, .do.verbose = .do.verbose, level = level)\n        if (aL[[\"continue\"]]) {\n           assign(name, anywhereList[[\"objs\"]][[1]], envir = newenvir)\n          .print.debug.message(.do.verbose, str_c(\"variable \", name, \" (\",typeof(anywhereList[[\"objs\"]][[1]]), \") stored.\"), level)\n          if (.do.verbose) {\n            print(ls(newenvir, all.names = TRUE))\n          }\n          \n        }\n        \n        return(list(object = anywhereList[[\"objs\"]][[1]], continue = aL[[\"continue\"]], listpackages = aL[[\"listpackages\"]], newenvir = newenvir))\n      }\n      NULL;\n    }, error = function(e) {return(NULL)} );\n  }\n  if (is.null(answerList)) {\n    warning(str_c(\"Could not find object \\\"\",name,\"\\\"\"))\n  }\n  return(answerList);\n}\n\n# this function analyse a namespace to decide wether it is associated with a R package which should be included in dependencies\n# depending of the namespace type (package, global environment, local environment), the enclosing recursion should continue or not \n# it returns recursion continuation decision and a new list of package dependences\n.appendLibraryDependencies <- function(namespace, .listpackages, .do.verbose, level) {\n  # remove the namespace prefix to get the package name\n  packageName <- str_replace(str_replace(namespace, fixed(\"namespace:\"), \"\"), fixed(\"package:\"), \"\")\n  if (!is.element(packageName, c(\"\",\".Primitive\", \"base\", \"datasets\", \"graphics\", \"methods\", \"stats\", \"utils\", \"R_GlobalEnv\", \".GlobalEnv\"))) {\n    # custom packages, stop recursion\n    .listpackages <- union(.listpackages, packageName);\n    .print.debug.message(.do.verbose, str_c(\"Package \", packageName, \" is required\"), level)\n    \n    return(list( continue=FALSE, listpackages = .listpackages))\n  } else if (is.element(packageName, c(\"\",\"R_GlobalEnv\", \".GlobalEnv\"))) {\n    # user-defined variables, continue recursion, store the variable\n    return(list( continue=TRUE, listpackages=.listpackages))\n  } else {\n    # standard packages, stop recursion\n    return(list( continue=FALSE, listpackages=.listpackages))\n  }\n}\n\n# similarly to .recurseSaveFunctionDependencies, this function recurse on the content of a list\n# which can contain other lists or even functions\n.recurseSaveListDependencies <- function(lstvarName, envir=NULL, newenvir=new.env(), .visitedNames={}, .libraryDependencies={}, .do.verbose=PADebug(), level = 1) {\n  .print.debug.message(.do.verbose, str_c(\"processing list: '\", lstvarName,\"'\"), level)\n  answerToFind <- .findAndStoreName(lstvarName, envir = envir, .listpackages = .libraryDependencies, newenvir=newenvir, .do.verbose = .do.verbose, level)\n  \n  if (!is.null(answerToFind)) {\n    newenvir <- answerToFind[[\"newenvir\"]]\n    .visitedNames <- union( .visitedNames, lstvarName)\n    .libraryDependencies <- answerToFind[[\"listpackages\"]]\n    if (!answerToFind[[\"continue\"]]) {\n      next\n    }\n    variableDefinition <- answerToFind[[\"object\"]]\n    computedDependencies <- {};\n    for(element in variableDefinition) {\n      typeofElement = typeof(element);\n      if (typeofElement == \"list\") {\n        # if the name is a list, recurse\n        recurseResult <- .recurseSaveListDependencies(element,envir=envir, newenvir = newenvir, .visitedNames=.visitedNames , .libraryDependencies=.libraryDependencies, .do.verbose=.do.verbose, level = level + 1)\n        computedDependencies <- union(computedDependencies, recurseResult[[\"deps\"]]);\n        .visitedNames <- union(.visitedNames, recurseResult[[\"visited\"]]);\n        .libraryDependencies <- union(.libraryDependencies, recurseResult[[\"libs\"]])\n        newenvir <- recurseResult[[\"newenvir\"]]\n      } else if (typeofElement == \"closure\") {\n        # if the name is a function, recurse\n        recurseResult <- .recurseSaveFunctionDependencies(element,envir=envir, newenvir = newenvir, .visitedNames=.visitedNames, .libraryDependencies=.libraryDependencies, .do.verbose=.do.verbose, level = level + 1)\n        computedDependencies <- union(computedDependencies, recurseResult[[\"deps\"]]);\n        .visitedNames <- union(.visitedNames, recurseResult[[\"visited\"]]);\n        .libraryDependencies <- union(.libraryDependencies, recurseResult[[\"libs\"]])\n        newenvir <- recurseResult[[\"newenvir\"]]\n      }\n      # any other type will be \"inside\" the list, no need to analyse it\n    }\n  }\n  return(list(deps = computedDependencies, visited = .visitedNames, libs = .libraryDependencies, newenvir = newenvir))\n};\n\n",
    "created" : 1434472632926.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2931879557",
    "id" : "7984025F",
    "lastKnownWriteTime" : 1434473639,
    "path" : "C:/Users/fviale/IdeaProjects/r_connector/par-connector/src/main/r/R/PASolve_saveDependencies.r",
    "project_path" : "R/PASolve_saveDependencies.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}