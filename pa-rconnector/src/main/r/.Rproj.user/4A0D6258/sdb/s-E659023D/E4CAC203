{
    "contents" : "### Common\n\nsetGeneric(\n  name=\"getName\",\n  def=function(object,value) {standardGeneric(\"getName\")}  \n)\n\nsetGeneric(\n  name=\"setName\",\n  def=function(object,value) {standardGeneric(\"setName\")}  \n) \n\nsetGeneric(\n  name=\"getJavaObject\",\n  def=function(object,value) {standardGeneric(\"getJavaObject\" )}  \n)\n\nsetGeneric(\n  name=\"getDefinition\",\n  def=function(object,value) {standardGeneric(\"getDefinition\")}  \n)\nsetGeneric(\n  name=\"setDefinition\",\n  def=function(object,value) {standardGeneric(\"setDefinition\")}  \n)\n\n### PAJob\n\nsetGeneric(\n  name=\"getProjectName\",\n  def=function(object,value) {standardGeneric(\"getProjectName\")}  \n)\nsetGeneric(\n  name=\"setProjectName\",\n  def=function(object,value) {standardGeneric(\"setProjectName\")}  \n) \nsetGeneric(\n  name=\"getPriority\",\n  def=function(object,value) {standardGeneric(\"getPriority\")}  \n)\nsetGeneric(\n  name=\"setPriority\",\n  def=function(object,value) {standardGeneric(\"setPriority\")}  \n) \nsetGeneric(\n  name=\"setCancelJobOnError\",\n  def=function(object,value) {standardGeneric(\"setCancelJobOnError\")}  \n) \nsetGeneric(\n  name=\"isCancelJobOnError\",\n  def=function(object,value) {standardGeneric(\"isCancelJobOnError\")}  \n) \n\nsetGeneric(\n  name=\"addTask<-\",\n  def=function(object,value) {standardGeneric(\"addTask<-\" )}  \n)\n\n\n### PATask\n\nsetGeneric(\n  name=\"getScript\",\n  def=function(object) {standardGeneric(\"getScript\")}  \n)\n\nsetGeneric(\n  name=\"setScript\",\n  def=function(object,value) {standardGeneric(\"setScript\")}  \n) \n\nsetGeneric(\n  name=\"getDescription\",\n  def=function(object,value) {standardGeneric(\"getDescription\" )}  \n) \n\nsetGeneric(\n  name=\"setDescription\",\n  def=function(object,value) {standardGeneric(\"setDescription\" )}  \n) \n\nsetGeneric(\n  name=\"getQuoteExp\",\n  def=function(object) {standardGeneric(\"getQuoteExp\")}  \n)\nsetGeneric(\n  name=\"getFileIndex\",\n  def=function(object) {standardGeneric(\"getFileIndex\")}  \n)\n\n\nsetGeneric(\n  name=\"getInputFiles\",\n  def=function(object,value) {standardGeneric(\"getInputFiles\" )}  \n)\n\nsetGeneric(\n  name=\"getOutputFiles\",\n  def=function(object,value) {standardGeneric(\"getOutputFiles\" )}  \n)\n\nsetGeneric(\n  name=\"getSelectionScripts\",\n  def=function(object,value) {standardGeneric(\"getSelectionScripts\" )}  \n)\n\nsetGeneric(\n  name=\"getPreScript\",\n  def=function(object,value) {standardGeneric(\"getPreScript\" )}  \n)\n\nsetGeneric(\n  name=\"setPreScript\",\n  def=function(object,value) {standardGeneric(\"setPreScript\" )}  \n)\n\nsetGeneric(\n  name=\"getPostScript\",\n  def=function(object,value) {standardGeneric(\"getPostScript\" )}  \n)\n\nsetGeneric(\n  name=\"setPostScript\",\n  def=function(object,value) {standardGeneric(\"setPostScript\" )}  \n)\n\nsetGeneric(\n  name=\"getCleanScript\",\n  def=function(object,value) {standardGeneric(\"getCleanScript\" )}  \n)\n\nsetGeneric(\n  name=\"setCleanScript\",\n  def=function(object,value) {standardGeneric(\"setCleanScript\" )}  \n)\n\nsetGeneric(\n  name=\"addDependency<-\",\n  def=function(object,value) {standardGeneric(\"addDependency<-\" )}  \n) \nsetGeneric(\n  name=\"getDependencies\",\n  def=function(object) {standardGeneric(\"getDependencies\" )}  \n) \n\nsetGeneric(\n  name=\"addInputFiles<-\",\n  def=function(object,value) {standardGeneric(\"addInputFiles<-\" )}  \n)\n\nsetGeneric(\n  name=\"addOutputFiles<-\",\n  def=function(object,value) {standardGeneric(\"addOutputFiles<-\" )}  \n)\n\nsetGeneric(\n  name=\"addSelectionScript\",\n  def=function(object,value,engine,is.dynamic) {standardGeneric(\"addSelectionScript\" )}  \n)\n\n### PAJobResult\n\n\n\n#' Waits for all results controlled by  a PAJobResult object\n#'\n#' PAWaitFor is used on a \\code{\\link{PAJobResult-class}} object to block the R interpreter until all results are available.\n#' The R result objects will be then returned inside a list. \n#' It is possible to wait for a subset instead of the whole list by using subscript indexing : PAWaitFor(res[1:3]) will wait for only the results at index 1,2,3.\n#'\n#' @param paresult a PAJobResult object\n#' @param timeout a long value specifying an optional timeout in milisecond\n#' @param client connection handle to the scheduler, if not provided the handle created by the last call to \\code{\\link{PAConnect}} will be used  (internal)\n#' @param callback a single parameter function which can be called when results are received. It can be useful to udapte graphical user interfaces for examples. Default to NULL.\n#' @param ... Additional argument list which are not used\n#' \n#' @return A list of results\n#' @rdname PAWaitFor\n#' @seealso \\code{\\link{PASolve}}, \\code{\\link{PAJobResult-class}} and \\code{\\link{PAWaitAny}}\n#' @export\nsetGeneric(\n  name=\"PAWaitFor\",\n  def=function(paresult = PALastResult(), ...) {standardGeneric(\"PAWaitFor\" )}  \n)\n\n\n#' Waits for the first available result\n#'\n#' PAWaitAny is used on a \\code{\\link{PAJobResult-class}} object to block the R interpreter until the first result is available.\n#' The R result object will be then returned as a factor, named by the task name. \n#' If the PAWaitAny is called a second time, then the second result will be waited and returned. After all results are consumed, a call to PAWaitAny will return NA.\n#'\n#' @param paresult a PAJobResult object\n#' @param timeout a long value specifying an optional timeout in milisecond\n#' @param client connection handle to the scheduler, if not provided the handle created by the last call to \\code{\\link{PAConnect}} will be used (internal)\n#' @param callback a single parameter function which can be called when results are received. It can be useful to udapte graphical user interfaces for examples. Default to NULL.\n#' @param ... Additional argument list which are not used\n#' \n#' @return A result\n#' @rdname PAWaitAny\n#' @seealso \\code{\\link{PASolve}}, \\code{\\link{PAJobResult-class}} and \\code{\\link{PAWaitAny}}\n#' @export\nsetGeneric(\n  name=\"PAWaitAny\",\n  def=function(paresult = PALastResult(), ...) {standardGeneric(\"PAWaitAny\" )}  \n)\n\n### PAFile\n\nsetGeneric(\n  name=\"setHash<-\",\n  def=function(object, value) {standardGeneric(\"setHash<-\")}  \n)\n\nsetGeneric(\n  name=\"pushFile\",\n  def=function(object, ...) {standardGeneric(\"pushFile\")}  \n)\n\nsetGeneric(\n  name=\"pullFile\",\n  def=function(object, ...) {standardGeneric(\"pullFile\")}  \n)\n\nsetGeneric(\n  name=\"getMode\",\n  def=function(object,input) {standardGeneric(\"getMode\")}  \n)\n\nsetGeneric(\n  name=\"getSelector\",\n  def=function(object) {standardGeneric(\"getSelector\")}  \n)\n\nsetGeneric(\n  name=\"isFileTransfer\",\n  def=function(object) {standardGeneric(\"isFileTransfer\")}  \n)\n\n\ncacheEnv <- new.env()\n\nPAClient <- function(client = NULL) {\n  if (exists(\".scheduler.client\", envir=cacheEnv)){\n    .scheduler.client <- get(\".scheduler.client\", envir=cacheEnv)\n  } else {\n    .scheduler.client <- NULL\n  }\n  if (nargs() == 1) {\n    .scheduler.client <- client        \n  }\n  assign(\".scheduler.client\", .scheduler.client, envir=cacheEnv)\n  return(.scheduler.client)\n}\n\n#' sets PARConnector Debug mode\n#'\n#' PADebug can be used either to set the Debug mode to on/off or to know the current state of the debug mode.\n#' \n#' In Debug mode a lot of verbose information will be printed (detailed content of PATask created, code analysis debugging, remote execution trace)\n#' \n#' @param debug to set the debug mode to on (TRUE) or off (FALSE)\n#' @return the current or new state of the debug mode\n#' \n#' @export\n#' @rdname PADebug\nPADebug <- function(debug=FALSE) {  \n  if (exists(\".is.debug\", envir=cacheEnv)){\n    .is.debug <- get(\".is.debug\", envir=cacheEnv)\n  } else {\n    .is.debug <- FALSE\n  }\n  \n  if (nargs() == 1) {\n    .is.debug <- debug        \n  }\n  assign(\".is.debug\", .is.debug, envir=cacheEnv)\n  return(.is.debug)\n}\n\nPAHandler <- function(e, .print.stack=TRUE) {    \n  if (.print.stack || PADebug()) {\n    if (PADebug()) {\n      print(\"Java Error in :\")\n      traceback(4)\n    }\n    e$jobj$printStackTrace()\n  }\n  stop(e)\n}\n\nPALastResult <- function(res = NULL) {    \n  if (exists(\".last.result\", envir=cacheEnv)){\n    .last.result <- get(\".last.result\", envir=cacheEnv)\n  } else {\n    .last.result <- NULL\n  }\n  if (nargs() == 1) {\n    .last.result <- res        \n  }\n  assign(\".last.result\", .last.result, envir=cacheEnv)\n  return(.last.result)\n}\n\n\n# returns a growing id used in PASolve\n.peekNewSolveId <- function() {  \n  # emulating local static variable\n  if (exists(\"pasolve.id\", envir=cacheEnv)){\n    id <- get(\"pasolve.id\", envir=cacheEnv)\n  } else {\n    id <- 0\n  }   \n  id <- id + 1\n      \n  return(id)\n}\n\n.commitNewSolveId <- function() {\n  id <- .peekNewSolveId()\n  assign(\"pasolve.id\", id, envir=cacheEnv)\n  if (exists(\"space.hash\", envir=cacheEnv)){\n    remove(\"space.hash\", envir=cacheEnv)\n  }\n  if (exists(\"patask.id\", envir=cacheEnv)){\n    remove(\"patask.id\", envir=cacheEnv)\n  }\n}\n\n.getNewTaskName <- function() {\n  if (exists(\"patask.id\", envir=cacheEnv)){\n    id <- get(\"patask.id\", envir=cacheEnv)\n  } else {\n    id <- 0\n  }   \n  id <- id + 1\n  assign(\"patask.id\", id, envir=cacheEnv)\n  \n  return(str_c(\"t\",id))\n}\n\n\n\n\n# computes a hash based on the hostname & the solve id & a time stamp\n# this is to guaranty that files used by a job will be put in a unique folder\n\n.getSpaceHash <- function() {\n  \n  if (exists(\"space.hash\", envir=cacheEnv)){\n    hash <- get(\"space.hash\", envir=cacheEnv)\n  } else {\n    id <- .peekNewSolveId()\n    localhost <- J(\"java.net.InetAddress\")$getLocalHost()\n    hname <- localhost$getHostName()\n    time <- Sys.time()\n    full_str <- str_c(hname, toString(id), time)\n    j_str <- .jnew(J(\"java.lang.String\"),full_str)\n    hcode <- j_str$hashCode()\n    hash <- str_replace_all(toString(hcode),fixed(\"-\"), \"_\")\n    assign(\"space.hash\", hash, envir=cacheEnv)\n  }     \n  return(hash)\n}\n\nj_try_catch <- defmacro(FUN, .print.stack = TRUE, .handler = NULL, expr={\n  tryCatch ({\n    return (FUN)\n  } , Exception = function(e) {\n    if (is.null(.handler)) {\n      PAHandler(e, .print.stack=.print.stack)\n    } else {\n      .handler(e, .print.stack=.print.stack)\n    }\n  })\n})\n\n.getSpaceName <- function(space) {\n  if (toupper(space) == \"INPUT\") {\n    return (\"INPUTSPACE\")\n  } else if (toupper(space) == \"OUTPUT\") {\n    return (\"OUTPUTSPACE\")\n  } else if (toupper(space) == \"GLOBAL\") {\n    return (\"GLOBALSPACE\")\n  } else if (toupper(space) == \"USER\") {\n    return (\"USERSPACE\")\n  }\n  return(space)\n}\n\n# macro which escapes parameters to evaluatable strings\n.param.to.remote.eval <- defmacro(param, expr = {\n  # print(str_c(\"eval(parse(text = '\",deparse(substitute(param)),\"'))\"))\n  .ptre.lines <- deparse(substitute(param))\n  .ptre.output <- \"eval(parse(text = c(\"\n  for (.ptre.i in 1:length(.ptre.lines)) {\n    .ptre.output <- str_c(.ptre.output,\"\\\"\",str_replace_all(.ptre.lines[.ptre.i],fixed(\"\\\"\"),\"\\\\\\\"\"),\"\\\"\")\n    if (.ptre.i < length(.ptre.lines)) {\n      .ptre.output <- str_c(.ptre.output,\", \")\n    }\n  }\n  .ptre.output <- str_c(.ptre.output,\")))\")\n  return(.ptre.output)\n})\n\n.cat_list <- function(ll) {\n  cat(.toString_list(ll))  \n}\n\n.toString_list <- function(ll) {\n  output <- t(\"{ \")\n  for (k in 1:length(ll)) {\n    output <- str_c(output,toString(ll[[k]]),\" \")\n    if (k < length(ll) ) {        \n      output <- str_c(output,\",\")     \n    }\n  }\n  output <- str_c(output,\"}\")\n  return(output)\n}\n\n.enum <- function ( name, ...)\n{\n  choices <- list( ... )\n  names   <- attr(choices,\"names\")\n  \n  pos <- pmatch( name, names )\n  \n  max <- length(names)\n  \n  if ( any( is.na(pos) ) )\n    stop(\"symbolic value must be chosen from \", list(names) )\n  else if ( (max+1) %in% pos )\n    pos <- seq_along(names)\n  \n  id  <- unlist(choices[pos])\n  \n  if ( length(id) > 1 )\n    stop(\"multiple choices not allowed\")\n  \n  return( id )\n}",
    "created" : 1428945659143.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2742473715",
    "id" : "E4CAC203",
    "lastKnownWriteTime" : 1434119663,
    "path" : "C:/Users/fviale/IdeaProjects/r_connector/par-connector/src/main/r/R/pa_inline_functions.r",
    "project_path" : "R/pa_inline_functions.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}