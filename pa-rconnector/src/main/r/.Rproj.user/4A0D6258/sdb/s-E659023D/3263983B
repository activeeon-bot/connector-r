{
    "contents" : "#' PAJobResult : stores a the result of a PASolve submission\n#' \n#' PAJobResult is a proxy object (S4 classes) which displays the current state of tasks\n#' Methods can be called on this object to wait until results are available.\n#' \n#' @slot job an S4 object of class PAJob (internal)\n#' @slot job.id the id of the job from ProActive Scheduler point of view\n#' @slot task.names names of tasks inside this job\n#' @slot client a connection to the scheduler (internal)\n#' @slot results a java object containing the Java results (internal)\n#' \n#' @examples\n#'  \\dontrun{\n#'      job <- PASolve('cos', 1:4)\n#'      \n#'      # get the job id\n#'      job@@job.id\n#'      \n#'      # status of task t1\n#'      job[\"t1\"]\n#'      \n#'      # wait for all results\n#'      vals <- PAWaitFor(job)\n#'      \n#'      # wait for result of task t2\n#'      vals <- PAWaitFor(job[\"t2\"])\n#'      \n#'      # wait for first available result\n#'      val <- PAWaitAny(job)\n#'  }\n#' \n#' @exportClass PAJobResult\nsetClass( \n  Class=\"PAJobResult\", \n  slots = c(\n    job = \"PAJob\",\n    job.id = \"character\",\n    task.names = \"character\",\n    client = \"jobjRef\",\n    results = \"jobjRef\"\n  ) ,\n  prototype=prototype(\n    job = NULL,\n    job.id = \"-1\",\n    task.names = \"\",\n    client = NULL,\n    results = NULL\n  )\n)\n\n\n\nPAJobResult <- function(job,jid,tnames, client) {\n  \n  results =  new(J(\"java.util.HashMap\"))\n  \n  new (Class=\"PAJobResult\" , job = job, job.id = jid, task.names = tnames, client=client, results = results)\n}\n\n#' [] extract parts of PAJobResult\n#'\n#' @describeIn PAJobResult\nsetMethod(\n  f=\"[\",\n  signature=\"PAJobResult\",\n  definition = function(x,i,j,drop) {\n      if (is.numeric(i)) {\n        selected.names <- x@task.names[i]          \n      } else if (is.character(i)) {\n        if (! is.element(i,x@task.names)) {\n          stop(\"Unknown task : \",i)\n        }\n        selected.names <- i    \n      }          \n      \n      return (new (Class=\"PAJobResult\" , job = x@job, job.id = x@job.id, task.names = selected.names, client = x@client, results = x@results))\n  }\n)\n\n#' [[]] extract parts of PAJobResult, equivalent to []\n#'\n#' @describeIn PAJobResult\nsetMethod(\n  f=\"[[\",\n  signature=\"PAJobResult\",\n  definition = function(x,i,j,drop) {\n    return(x[i])\n  }\n)\n\n.getLogsFromJavaResult <- function(paresult, tresult) {              \n  jlogs <- tresult$getOutput()         \n  logs <- jlogs$getAllLogs(TRUE)\n  \n  return(logs)\n}\n\n.getRResultFromJavaResult <- function(paresult, tresult, i, callback) {\n  if(tresult$hadException()) {  \n    return(simpleError(tresult$value()))               \n  } else {\n    # transferring output files\n    tasks <- paresult@job@tasks\n    \n    outfiles <- tasks[[paresult@task.names[i]]]@outputfiles\n    if (length(outfiles) > 0) {\n      for (j in 1:length(outfiles)) {\n        pafile <- outfiles[[j]]\n        if (isFileTransfer(pafile)) {\n          pullFile(pafile, client = paresult@client)\n        }\n      }\n    }\n\n    jobj <- tresult$value()\n    robj <- .unserializeObj(jobj)\n\n    if (!is.null(callback)) {\n       return(callback(robj))\n    }\n    return(robj)\n  }\n\n}\n\n.unserializeObj <- function(obj) {\n    if (class(obj) == \"jobjRef\") {\n      rexp <- J(\"org.rosuda.jrs.RexpConvert\")$jobj2rexp(obj)\n      eng <- .jengine()\n      eng.assign(\"tmpoutput\",rexp)\n      obj <- tmpoutput\n    }\n    if (is.na(obj) || is.null(obj)) {\n      return(obj)\n    } else {\n      return(unserialize(obj))\n    }\n}\n\nsetClassUnion(\"PAJobResultOrMissing\", c(\"PAJobResult\", \"missing\"))\n\n.getAvailableResults <- function(paresult, callback) {\n\n  tnames <- paresult@task.names\n  results <- setNames(vector(\"list\",length(tnames)),tnames)\n  for (i in 1:length(tnames)) {  \n    tresult <- paresult@results$get(tnames[i])\n    \n    if (!is.null(tresult)) {\n      log <- .getLogsFromJavaResult(paresult, tresult)\n      if (!is.null(log) && !(log == \"\")) {\n        cat(str_c(tnames[i], \" : \"))\n        cat(\"\\n\")\n        cat(log)\n        cat(\"\\n\")\n      }\n      result <- .getRResultFromJavaResult(paresult, tresult, i, callback)\n      if (is.null(result)) {\n        # nothing to do, the list is initialized with null elements\n        # i.e. list[[i]] <- NULL actually removes the element i in the list\n      } else {\n        results[[tnames[i]]] <- result\n      }\n    }\n  }\n  return(results)\n}\n\n#' @describeIn PAWaitFor\nsetMethod(\"PAWaitFor\",\"PAJobResultOrMissing\", function(paresult = PALastResult(), timeout = .Machine$integer.max, client = PAClient(), callback = NULL) {\n            \n            if (client == NULL || is.jnull(client) ) {\n              stop(\"You are not currently connected to the scheduler, use PAConnect\")\n            }             \n            \n            tnames <- paresult@task.names            \n            \n            selected.names <- NULL\n            task.list <- .jnew(J(\"java.util.ArrayList\"))\n            \n            \n            for (i in 1:length(tnames)) {\n              if (is.null(paresult@results$get(tnames[i]))) {\n                selected.names <- c(selected.names,tnames[i])\n                task.list$add(tnames[i])\n              }\n            }       \n            if (task.list$size() > 0) {\n              tryCatch ({\n                listentry <- client$waitForAllTasks(paresult@job.id,task.list,.jlong(timeout))\n              } , Exception = function(e) {\n                e$jobj$printStackTrace()\n                stop()\n              })           \n              \n              for (i in 0:(task.list$size()-1)) {              \n                entry <- listentry$get(as.integer(i))             \n                tresult <- entry$getValue()  \n                \n                paresult@results$put(selected.names[i+1], tresult)                                                \n              }\n            }\n            \n            return (.getAvailableResults(paresult, callback))            \n            \n          }\n)\n\n#' @describeIn PAWaitAny\nsetMethod(\"PAWaitAny\",\"PAJobResultOrMissing\", function(paresult = PALastResult(), timeout = .Machine$integer.max, client = PAClient(), callback = NULL) {\n  \n  if (client == NULL || is.jnull(client) ) {\n    stop(\"You are not currently connected to the scheduler, use PAConnect\")\n  }             \n  \n  tnames <- paresult@task.names            \n  \n  selected.names <- NULL\n  task.list <- .jnew(J(\"java.util.ArrayList\"))\n  \n  \n  for (i in 1:length(tnames)) {\n    if (is.null(paresult@results$get(tnames[i]))) {\n      selected.names <- c(selected.names,tnames[i])\n      task.list$add(tnames[i])\n    }\n  }       \n  if (task.list$size() > 0) {\n    tryCatch ({\n      entry <- client$waitForAnyTask(paresult@job.id,task.list,.jlong(timeout))\n    } , Exception = function(e) {\n      e$jobj$printStackTrace()\n      stop()\n    })      \n    \n    tname <- entry$getKey()\n    tresult <- entry$getValue() \n    \n    paresult@results$put(tname, tresult)   \n    res <- .getAvailableResults(paresult, callback)\n    return(res[tname])\n  }\n  return(NA)\n  \n  \n}\n)\n\nsetMethod(\"toString\",\"PAJobResult\",\n          function(x, width = NULL, ...) {\n            object <- x \n            output.list <- list()\n            \n            job.name = getName(object@job)\n            state <- object@client$getJobState(object@job.id)\n            task.states.list <- state$getTasks()\n            output <- str_c(job.name,\" (id: \",object@job.id,\") \",\" (status: \",state$getStatus()$toString(),\")\",\"\\n\")            \n            if (task.states.list$size() > 0) {              \n              for (i in 0:(task.states.list$size()-1)) {\n                task.state <- task.states.list$get(as.integer(i))\n                if (is.element(task.state$getName(), object@task.names)) {\n                  taskindex <- strtoi(str_sub(task.state$getName(),2))\n                  status <- task.state$getStatus()$toString()\n                  if (status == \"Running\") {\n                    output.list[[taskindex]] <- str_c(task.state$getName(), \" : \",  task.state$getStatus()$toString(), \" at \",task.state$getTaskInfo()$getExecutionHostName(),\" (\",task.state$getProgress(),\"%)\")\n                  } else if (status == \"Finished\") {\n                    date <- new(J(\"java.util.Date\"),.jlong(task.state$getTaskInfo()$getFinishedTime()))\n                    output.list[[taskindex]] <- str_c(task.state$getName(), \" : \",  task.state$getStatus()$toString(), \" at \", date$toString())\n                  } else {\n                    output.list[[taskindex]] <- str_c(task.state$getName(), \" : \",  task.state$getStatus()$toString())\n                  }\n                  \n                }\n              }\n              for (i in 1:length(output.list)) {\n                output <- str_c(output,output.list[[i]],\"\\n\")\n              }\n            }\n            return(output)\n          }\n)\n\nsetMethod(\"show\" ,\"PAJobResult\" ,\n          function(object) {\n            cat(toString(object))                                 \n          } \n)\n\nsetMethod(\"print\" ,\"PAJobResult\" ,\n          function(x,...) {\n            print(toString(object))                                 \n          } \n)\n",
    "created" : 1433953126082.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "360291028",
    "id" : "3263983B",
    "lastKnownWriteTime" : 1434119867,
    "path" : "C:/Users/fviale/IdeaProjects/r_connector/par-connector/src/main/r/R/PAJobResult.r",
    "project_path" : "R/PAJobResult.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}