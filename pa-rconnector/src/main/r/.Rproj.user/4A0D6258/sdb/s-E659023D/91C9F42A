{
    "contents" : ".compute.task.dependencies <- function(task,envir) {\n  tname <- getName(task)\n  task.names <- get(\"task.names\",envir)\n  all.tasks <- get(\"all.tasks\",envir)\n  \n  if (!is.element(tname,task.names)) {\n    task.names <- c(task.names,tname)\n    all.tasks <- c(all.tasks, task)\n    assign(\"task.names\",task.names,envir)\n    assign(\"all.tasks\",all.tasks,envir)\n    deps <- getDependencies(task)\n    if (length(deps) > 0) {\n      for (ii in 1:length(deps)) {\n        .compute.task.dependencies(deps[[ii]],envir)\n      }\n    }\n  }\n}\n\n#' Create and submit a ProActive R Job\n#' \n#' \\code{PASolve} take in parameter a list of PATasks produced by \\code{\\link{PA}} \\code{\\link{PAS}} or \\code{\\link{PAM}} calls and submits a new job to ProActive Scheduler. \n#' \n#' a \\code{\\link{PAJobResult-class}} object will be returned. The object will bear the current state of the job, which can be displayed simply by showing or printing the object.\n#' Special functions \\code{\\link{PAWaitFor}} and \\code{\\link{PAWaitAny}} can be used to wait for the results.\n#' \n#'  @param ... list of PATasks produced by \\code{\\link{PA}} \\code{\\link{PAS}} or \\code{\\link{PAM}} calls\n#'  @param client connection handle to the scheduler, if not provided the handle created by the last call to \\code{\\link{PAConnect}} will be used\n#'  @param .debug Debug mode or not. Default is the value of the PADebug setting\n#'  @param jobName name of the ProActive job to be created\n#'  @param jobDescription description of this job\n#'  @param priority priority of this job\n#'  @param cancelOnError sets the cancelling mode mechanism whenever an error occur in one tasks, does it cancel the whole job ? Default to TRUE\n#'  @return a \\code{\\link{PAJobResult-class}} object which acts as a placeholder for receiving actual results\n#'  @examples\n#'  \\dontrun{\n#'  \n#'  > res = PASolve(\"cos\",1:4)   # shortcut for PASolve(PA(\"cos\",1:4)), submits a parallel job of 4 tasks\n#'  Job submitted (id : 405)\n#'  with tasks : t1, t2, t3, t4\n#'  > res                            # display the current state\n#'  PARJob1 (id: 405)  (status: Running)\n#'  t1 : Pending\n#'  t2 : Running at 192.168.1.187 (local-LocalNodes-0) (0%)\n#'  t3 : Running at 192.168.1.187 (local-LocalNodes-2) (0%)\n#'  t4 : Pending\n#'  > PAWaitFor(res)                 # wait for the results and return them in a list\n#'  $t1\n#'  [1] 0.5403023\n#'\n#'  $t2\n#'  [1] -0.4161468\n#'\n#'  $t3\n#'  [1] -0.9899925\n#'\n#'  $t4\n#'  [1] -0.6536436\n#'  \n#'  \n#'  \n#'  > res = PASolve(PAM(\"sum\",\n#'                  PA(function(x) {x*x},\n#'                    PAS(\"identity\", 1:4))))         # submits a split/merge job of six tasks\n#'                    \n#'  > res\n#'  PARJob2 (id: 406)  (status: Running)\n#'  t1 : Running at 192.168.1.187 (local-LocalNodes-0) (0%)\n#'  t2 : Pending\n#'  t3 : Pending\n#'  t4 : Pending\n#'  t5 : Pending\n#'  t6 : Pending\n#'  \n#'  > PAWaitFor(res)        # wait for the results and return them in a list\n#'  $t1\n#'  [1] 1 2 3 4\n#'  \n#'  $t2\n#'  [1] 1\n#'  \n#'  $t3\n#'  [1] 4\n#'  \n#'  $t4\n#'  [1] 9\n#'  \n#'  $t5\n#'  [1] 16\n#'  \n#'  $t6\n#'  [1] 30\n#'  }\n#'  @seealso  \\code{\\link{PA}} \\code{\\link{PAS}} \\code{\\link{PAM}} \\code{\\link{PAWaitFor}} \\code{\\link{PAWaitAny}} \\code{\\link{PAConnect}}\n#'  @export\nPASolve <- function(..., client = PAClient(), .debug = PADebug(), jobName = str_c(\"PARJob\",.peekNewSolveId()) , jobDescription = \"ProActive R Job\", priority = \"normal\", cancelOnError = TRUE) {  \n  \n  dots <- list(...)\n  \n  if (length(dots) == 0) {\n    stop(\"Not enough arguments\")\n  }\n  \n  if (client == NULL || is.jnull(client) ) {\n    stop(\"You are not currently connected to the scheduler, use PAConnect\")\n  } \n  \n  \n  cl <- class(dots[[1]])\n  if ((cl == \"function\") || (cl == \"character\")) {\n    # simplified syntax (a simple parametric sweep) => rebuild a new call\n    answer <- do.call(\"PASolve\",list(do.call(\"PA\",dots,envir=parent.frame())), envir=parent.frame())\n    return (answer)\n  }    \n  \n  jobresult <- tryCatch (\n{  \n  .peekNewSolveId()\n  job <- PAJob(jobName, jobDescription)\n  setPriority(job, priority)\n  setCancelJobOnError(job, cancelOnError)\n  task.names <- NULL\n  all.tasks <- list()\n  \n  for (i in 1:length(dots)) {\n    tasklist <- dots[[i]]\n    \n    for (j in 1:length(tasklist)) {\n      .compute.task.dependencies(tasklist[[j]],environment())    \n    }\n  }\n  # sort tasks by their names\n  unordered <- unlist(lapply(task.names, function(x)strtoi(str_sub(x,2))))\n  new.indexes <- sort(unordered,index.return=TRUE)\n  task.names <- task.names[new.indexes[[\"ix\"]]]\n  all.tasks <- all.tasks[new.indexes[[\"ix\"]]]\n  \n  for (i in 1:length(all.tasks)) {\n    addTask(job) <- all.tasks[[i]]\n  }\n  \n  if (.debug) {\n    print(\"Submitting job : \")\n    cat(toString(job))\n  }\n  jobid <- j_try_catch(client$submit(getJavaObject(job)))\n  cat(str_c(\"Job submitted (id : \",jobid$value(),\")\",\"\\n\",\" with tasks : \",toString(task.names),\"\\n\"))\n  \n  jobresult <- PAJobResult(job, jobid$value(),  task.names, client)  \n  PALastResult(jobresult)\n  return(jobresult)\n}, finally = {\n  .commitNewSolveId()\n})\n  \n};",
    "created" : 1433954191177.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2427304678",
    "id" : "91C9F42A",
    "lastKnownWriteTime" : 1434358152,
    "path" : "C:/Users/fviale/IdeaProjects/r_connector/par-connector/src/main/r/R/PASolve.r",
    "project_path" : "R/PASolve.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}